from unified_planning.shortcuts import *
from unified_planning.model.metrics import *
from unified_planning.io import PDDLWriter

# For some reason we get a warning that Optimal Fast Downward can't solve this type of problem (it can),
# we'll just ignore the warning:
import warnings
warnings.simplefilter("ignore", UserWarning)

# TODO: Add any helper functions and libraries you need

def Get_Total_Cost(plan, mac):
    total_cost = 0
    for a in plan.actions:
        total_cost += mac[a.action]._content.payload
    return total_cost

def main():
    # TODO: Represent and solve the optimal numeric Travelling Jedi Problem using the UPF
    problem_tjp_num_opt = None
    plan = None # This is the plan generated by your solver (as type SequentialPlan)
    mac = {} # This is the dictionary that stores the action costs

    # This function will display the total cost of your solution
    total_cost = Get_Total_Cost(plan, mac)
    print(f"\nTotal Cost of the Optimal Path: {total_cost} parsecs")

    # Writing the PDDl files
    w = PDDLWriter(problem_tjp_num_opt)
    w.write_domain('Jedi/domain_upf_tjp_num_opt.pddl')
    w.write_problem('Jedi/problem_upf_tjp_num_opt.pddl')
    return

if __name__ == '__main__':
    main()